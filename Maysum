import os
import tkinter as tk
from tkinter import filedialog, Listbox, messagebox, ttk, Label
import pygame
from mutagen.mp3 import MP3
import time
import threading
import random

class AdvancedMusicPlayer:
    def __init__(self, root):  # Corrected from _init to _init
        self.root = root
        self.root.title("Music Player")
        self.root.geometry("500x615")
        self.theme = 'light'  # default theme
        self.button_width = 50

        # Initialize Pygame mixer
        pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)

        # Variables
        self.current_song = None
        self.is_paused = False
        self.playlist = []
        self.playing = False
        self.current_time = 0
        self.song_length = 0
        self.song_title_var = tk.StringVar()
        self.music_folder = None
        self.volume_level = 5  # Default volume level set to 50% initially
        self.repeat = False  # Repeat flag

        # Create widgets
        self.create_widgets()

        # Set initial volume
        pygame.mixer.music.set_volume(self.volume_level / 10)
        self.volume_slider.set(self.volume_level)

        # Ask user to select a music folder
        self.select_music_folder()

        # Start the event listener for end of song
        self.root.after(100, self.check_for_song_end)

    def create_widgets(self):
        # Playlist box
        self.playlist_box = Listbox(self.root, selectmode=tk.SINGLE, bg="lightblue", fg="black", font=('Times New Roman', 12), width=50, height=15)
        self.playlist_box.pack(pady=(10, 5))

        # Song info
        self.song_info_label = Label(self.root, textvariable=self.song_title_var, font=('Times New Roman', 12), fg="blue")
        self.song_title_var.set("No song playing")
        self.song_info_label.pack(pady=(5, 2))

        # Volume control slider
        self.volume_slider = tk.Scale(self.root, from_=0, to=10, orient=tk.HORIZONTAL, resolution=0.1, label="Volume", command=self.set_volume)
        self.volume_slider.pack(pady=(5, 2))

        # Progress bar (seekbar)
        self.seek_bar = ttk.Scale(self.root, from_=0, to=100, orient=tk.HORIZONTAL, length=400, command=self.seek_song)
        self.seek_bar.pack(pady=10)

        # Labels for current time and duration
        self.current_time_label = Label(self.root, text="0:00", font=('Times New Roman', 10), fg="black")
        self.current_time_label.place(relx=0.02, rely=0.695)

        self.duration_label = Label(self.root, text="0:00", font=('Times New Roman', 10), fg="black")
        self.duration_label.place(relx=0.90, rely=0.695)

        # Control buttons with text labels instead of images
        control_frame = tk.Frame(self.root)
        control_frame.pack(pady=10)
    
        shuffle_button = tk.Button(control_frame, text="Shuffle", command=self.shuffle_playlist)
        shuffle_button.grid(row=0, column=0, padx=10)   # Use grid layout

        prev_button = tk.Button(control_frame, text="Previous", command=self.previous_song)
        prev_button.grid(row=0, column=1, padx=10)

        self.play_pause_button = tk.Button(control_frame, text="Play", command=self.toggle_play_pause)
        self.play_pause_button.grid(row=0, column=2, padx=10)  
    
        next_button = tk.Button(control_frame, text="Next", command=self.next_song)
        next_button.grid(row=0, column=3, padx=10)

        repeat_button = tk.Button(control_frame, text="Repeat", command=self.toggle_repeat)
        repeat_button.grid(row=0, column=4, padx=10)
        
        stop_button = tk.Button(control_frame, text="Stop", command=self.stop_song)
        stop_button.grid(row=0, column=5, padx=10)

        # Add/Remove songs buttons on the same line
        add_remove_frame = tk.Frame(self.root)
        add_remove_frame.pack(pady=10)

        add_button = tk.Button(add_remove_frame, text="Add Songs", command=self.add_songs)
        remove_button = tk.Button(add_remove_frame, text="Remove Song", command=self.remove_song)

        add_button.pack(side=tk.LEFT, padx=(0, 5))
        remove_button.pack(side=tk.LEFT)

        # Dark mode toggle
        toggle_theme_button = tk.Button(self.root, text="Toggle Dark Mode", command=self.toggle_theme)
        toggle_theme_button.pack(pady=10)


    def select_music_folder(self):
        """Prompt the user to select a folder with music files."""
        folder_selected = filedialog.askdirectory(title="Select Music Folder")
        if folder_selected:
            self.music_folder = folder_selected
            self.load_songs_from_folder()
        else:
            messagebox.showerror("Error", "No folder selected. Please select a valid folder.")

    def load_songs_from_folder(self):
        """Automatically loads all mp3 files from the selected folder."""
        if self.music_folder and os.path.exists(self.music_folder):
            songs = [f for f in os.listdir(self.music_folder) if f.endswith('.mp3')]
            for song in songs:
                song_path = os.path.join(self.music_folder, song)
                self.playlist.append(song_path)
                self.playlist_box.insert(tk.END, song)

    def add_songs(self):
        """Add selected songs to the playlist."""
        songs = filedialog.askopenfilenames(initialdir="C:/", title="Choose Songs", filetypes=(("mp3 Files", "*.mp3"),))
        for song in songs:
            song_name = os.path.basename(song)
            self.playlist_box.insert(tk.END, song_name)
            self.playlist.append(song)

    def remove_song(self):
        """Remove the selected song from the playlist."""
        selected_song = self.playlist_box.curselection()
        if selected_song:
            self.playlist_box.delete(selected_song)
            del self.playlist[selected_song[0]]

    def play_song_in_thread(self):
        """Offload the song playing into a separate thread to avoid UI blocking."""
        threading.Thread(target=self.play_song).start()

    def toggle_play_pause(self):
        """Toggle play and pause states."""
        if self.playing:
            self.pause_song()  # If currently playing, pause
            self.play_pause_button.config(text="Play")  # Change button text to "Play"
        elif self.is_paused:
            self.resume_song()  # If currently paused, resume playback
            self.play_pause_button.config(text="Pause")  # Change button text to "Pause"
        else:
            self.play_song_in_thread()  # If currently stopped, play using a thread
            self.play_pause_button.config(text="Pause")  # Change button text to "Pause"

    def play_song(self):
        """Play the selected song."""
        if self.playlist_box.curselection():
            selected_song = self.playlist_box.curselection()[0]
            song_path = self.playlist[selected_song]
            self.current_song = song_path
            
            # Debug output to see if the song is being loaded
            # print(f"Attempting to play song: {song_path}")

            try:
                # Load the song and get its length
                pygame.mixer.music.load(song_path)
                audio = MP3(song_path)
                self.song_length = audio.info.length

                pygame.mixer.music.play(loops=0)  # Play the song from the start
                self.display_song_info(song_path)
                self.playing = True
                self.is_paused = False  # Reset pause state

                # Update the seekbar and labels regularly
                self.update_seekbar()
            except Exception as e:
                print(f"Error playing song: {e}")
        else:
            print("No song selected to play.")

    def resume_song(self):
        """Resume the paused song."""
        if self.is_paused:
            pygame.mixer.music.unpause()  # Unpause the song
            self.is_paused = False  # Update the pause state
            self.playing = True  # Update playing state
            self.play_pause_button.config(text="Pause")  # Update button text
            self.update_seekbar()  # Restart the seekbar update thread

    def pause_song(self):
        """Pause the current song."""
        if self.playing:
            pygame.mixer.music.pause()
            self.is_paused = True
            self.playing = False
            self.seekbar_updater_active = False  # Stop the seekbar update thread

    def seek_song(self, val):
        """Seek the song to a certain position based on the seek bar value."""
        if self.song_length > 0:  # Check if song length is valid
            position = float(val) / 100 * self.song_length  # Calculate position in seconds
            pygame.mixer.music.set_pos(position)  # Seek to the calculated position

    def stop_song(self):
        """Stop the current song."""
        pygame.mixer.music.stop()
        self.playing = False
        self.current_time = 0
        self.seek_bar.set(0)
        self.current_time_label.config(text="0:00")
        self.duration_label.config(text="0:00")
        self.play_pause_button.config(text="Play")  # Reset play/pause button

    def next_song(self):
        """Play the next song in the playlist."""
        selected_song_index = self.playlist_box.curselection()
        
        # Debugging: Check what the current selection is
        # print(f"Current selected index: {selected_song_index}")
        
        if selected_song_index:  # Check if a song is selected
            selected_index = selected_song_index[0]
            next_index = (selected_index + 1) % len(self.playlist)  # Wrap around
        else:
            next_index = 0  # Default to the first song if none is selected

        # Debugging: Check which song is selected next
        # print(f"Next selected index: {next_index}, Next song: {self.playlist[next_index]}")

        self.playlist_box.selection_clear(0, tk.END)  # Clear current selection
        self.playlist_box.selection_set(next_index)  # Select the next song
        self.play_song_in_thread()  # Play the next song

    def previous_song(self):
        """Play the previous song in the playlist."""
        selected_song_index = self.playlist_box.curselection()[0]
        prev_index = (selected_song_index - 1) % len(self.playlist)  # Wrap around
        self.playlist_box.selection_clear(selected_song_index)
        self.playlist_box.selection_set(prev_index)
        self.play_song_in_thread()

    def shuffle_playlist(self):
        """Shuffle the songs in the playlist, but keep the current song in place."""
        if self.current_song:
            current_song_index = self.playlist.index(self.current_song)  # Get the index of the current song
            current_song = self.playlist.pop(current_song_index)  # Remove the current song from the list temporarily
            random.shuffle(self.playlist)  # Shuffle the remaining songs
            self.playlist.insert(0, current_song)  # Insert the current song back at the start of the playlist

            # Update the playlist box
            self.playlist_box.delete(0, tk.END)
            for song_path in self.playlist:
                song_name = os.path.basename(song_path)
                self.playlist_box.insert(tk.END, song_name)

            # Reselect the current song in the playlist box
            self.playlist_box.selection_set(0)
        else:
            random.shuffle(self.playlist)
            self.playlist_box.delete(0, tk.END)
            for song_path in self.playlist:
                song_name = os.path.basename(song_path)
                self.playlist_box.insert(tk.END, song_name)

    def toggle_repeat(self):
        """Toggle repeat mode on or off."""
        self.repeat = not self.repeat
        status = "ON" if self.repeat else "OFF"
        messagebox.showinfo("Repeat Mode", f"Repeat mode is now {status}")

    def set_volume(self, val):
        """Set the volume of the music player."""
        volume = float(val) / 10
        pygame.mixer.music.set_volume(volume)

    def display_song_info(self, song_path):
        """Update the song title and duration."""
        song_title = os.path.basename(song_path)
        self.song_title_var.set(song_title)
        mins, secs = divmod(self.song_length, 60)
        self.duration_label.config(text=f"{int(mins)}:{int(secs):02d}")      
    
    def update_seekbar(self):
        """Update the seekbar and song time labels."""
        def update():
            while self.playing:
                if not pygame.mixer.music.get_busy():
                    break  # Exit loop if music is not playing
                self.current_time = pygame.mixer.music.get_pos() / 1000
                mins, secs = divmod(self.current_time, 60)
                self.current_time_label.config(text=f"{int(mins)}:{int(secs):02d}")
                if self.song_length > 0:
                    self.seek_bar.set((self.current_time / self.song_length) * 100)
                remaining_time = self.song_length - self.current_time
                self.duration_label.config(text=f"- {time.strftime('%M:%S', time.gmtime(remaining_time))}")
                time.sleep(1)

        threading.Thread(target=update).start()

    def check_for_song_end(self):
        """Check if the song has ended and handle accordingly."""
        if self.playing and not pygame.mixer.music.get_busy():
            if self.repeat:
                self.play_song_in_thread()
            else:
                self.next_song()  # This will now correctly select and play the next song
        self.root.after(100, self.check_for_song_end)

    def toggle_theme(self):
        if self.theme == 'light':
            # Dark Theme
            self.root.configure(bg='#121212')  # Dark background
            self.playlist_box.configure(bg='#1E1E1E', fg='white')
            self.song_info_label.configure(bg='#121212', fg='white')
            self.volume_slider.configure(bg='#1E1E1E', fg='white')
            self.theme = 'dark'

            # Update ttk styles for dark theme
            self.style = ttk.Style()
            self.style.theme_use('clam')
            self.style.configure("TScale", background='#1E1E1E', troughcolour='#3C3C3C', sliderrelief='flat', borderwidth=1)
            self.style.configure("TProgressbar", background='#3C3C3C')
            self.style.configure("TButton", relief='flat', background='#1E1E1E', foreground='white', borderwidth=1)
            self.style.map("TButton", background=[('active', '#3C3C3C')])

        else:
            # Light Theme
            self.root.configure(bg='#FFFFFF')  # Light background
            self.playlist_box.configure(bg='#F0F0F0', fg='black')
            self.song_info_label.configure(bg='#FFFFFF', fg='blue')
            self.volume_slider.configure(bg='#F0F0F0', fg='black')
            self.theme = 'light'

            # Update ttk styles for light theme
            self.style = ttk.Style()
            self.style.theme_use('clam')
            self.style.configure("TScale", background='#F0F0F0', troughcolour='#B0B0B0', sliderrelief='flat', borderwidth=1)
            self.style.configure("TProgressbar", background='#B0B0B0')
            self.style.configure("TButton", relief='flat', background='#F0F0F0', foreground='black', borderwidth=1)
            self.style.map("TButton", background=[('active', '#D0D0D0')])

# Run the application
root = tk.Tk()
app = AdvancedMusicPlayer(root)
root.mainloop()
